// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.7
// 	protoc        v6.31.1
// source: proto/echo.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EchoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EchoRequest) Reset() {
	*x = EchoRequest{}
	mi := &file_proto_echo_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EchoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EchoRequest) ProtoMessage() {}

func (x *EchoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EchoRequest.ProtoReflect.Descriptor instead.
func (*EchoRequest) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{0}
}

func (x *EchoRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type EchoResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Message       string                   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Headers       map[string]*HeaderValues `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	RemoteAddr    string                   `protobuf:"bytes,3,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	TlsInfo       *TLSInfo                 `protobuf:"bytes,4,opt,name=tls_info,json=tlsInfo,proto3" json:"tls_info,omitempty"`
	Env           map[string]string        `protobuf:"bytes,5,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EchoResponse) Reset() {
	*x = EchoResponse{}
	mi := &file_proto_echo_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EchoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EchoResponse) ProtoMessage() {}

func (x *EchoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EchoResponse.ProtoReflect.Descriptor instead.
func (*EchoResponse) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{1}
}

func (x *EchoResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *EchoResponse) GetHeaders() map[string]*HeaderValues {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *EchoResponse) GetRemoteAddr() string {
	if x != nil {
		return x.RemoteAddr
	}
	return ""
}

func (x *EchoResponse) GetTlsInfo() *TLSInfo {
	if x != nil {
		return x.TlsInfo
	}
	return nil
}

func (x *EchoResponse) GetEnv() map[string]string {
	if x != nil {
		return x.Env
	}
	return nil
}

type HeaderValues struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []string               `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderValues) Reset() {
	*x = HeaderValues{}
	mi := &file_proto_echo_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderValues) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderValues) ProtoMessage() {}

func (x *HeaderValues) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderValues.ProtoReflect.Descriptor instead.
func (*HeaderValues) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{2}
}

func (x *HeaderValues) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type TLSInfo struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	Version                string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	CipherSuite            string                 `protobuf:"bytes,2,opt,name=cipher_suite,json=cipherSuite,proto3" json:"cipher_suite,omitempty"`
	AlpnNegotiatedProtocol string                 `protobuf:"bytes,3,opt,name=alpn_negotiated_protocol,json=alpnNegotiatedProtocol,proto3" json:"alpn_negotiated_protocol,omitempty"`
	PeerCertificates       []*TLSCertificateInfo  `protobuf:"bytes,4,rep,name=peer_certificates,json=peerCertificates,proto3" json:"peer_certificates,omitempty"`
	ServerName             string                 `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	KeyExchange            string                 `protobuf:"bytes,6,opt,name=key_exchange,json=keyExchange,proto3" json:"key_exchange,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *TLSInfo) Reset() {
	*x = TLSInfo{}
	mi := &file_proto_echo_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSInfo) ProtoMessage() {}

func (x *TLSInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSInfo.ProtoReflect.Descriptor instead.
func (*TLSInfo) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{3}
}

func (x *TLSInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TLSInfo) GetCipherSuite() string {
	if x != nil {
		return x.CipherSuite
	}
	return ""
}

func (x *TLSInfo) GetAlpnNegotiatedProtocol() string {
	if x != nil {
		return x.AlpnNegotiatedProtocol
	}
	return ""
}

func (x *TLSInfo) GetPeerCertificates() []*TLSCertificateInfo {
	if x != nil {
		return x.PeerCertificates
	}
	return nil
}

func (x *TLSInfo) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *TLSInfo) GetKeyExchange() string {
	if x != nil {
		return x.KeyExchange
	}
	return ""
}

type TLSCertificateInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Subject       string                 `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Issuer        string                 `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	SerialNumber  string                 `protobuf:"bytes,3,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	NotBefore     string                 `protobuf:"bytes,4,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	NotAfter      string                 `protobuf:"bytes,5,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TLSCertificateInfo) Reset() {
	*x = TLSCertificateInfo{}
	mi := &file_proto_echo_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSCertificateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSCertificateInfo) ProtoMessage() {}

func (x *TLSCertificateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSCertificateInfo.ProtoReflect.Descriptor instead.
func (*TLSCertificateInfo) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{4}
}

func (x *TLSCertificateInfo) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *TLSCertificateInfo) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

func (x *TLSCertificateInfo) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *TLSCertificateInfo) GetNotBefore() string {
	if x != nil {
		return x.NotBefore
	}
	return ""
}

func (x *TLSCertificateInfo) GetNotAfter() string {
	if x != nil {
		return x.NotAfter
	}
	return ""
}

type EchoCountdownRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         int32                  `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EchoCountdownRequest) Reset() {
	*x = EchoCountdownRequest{}
	mi := &file_proto_echo_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EchoCountdownRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EchoCountdownRequest) ProtoMessage() {}

func (x *EchoCountdownRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EchoCountdownRequest.ProtoReflect.Descriptor instead.
func (*EchoCountdownRequest) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{5}
}

func (x *EchoCountdownRequest) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

type EchoCountdownResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Count         int32                  `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EchoCountdownResponse) Reset() {
	*x = EchoCountdownResponse{}
	mi := &file_proto_echo_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EchoCountdownResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EchoCountdownResponse) ProtoMessage() {}

func (x *EchoCountdownResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_echo_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EchoCountdownResponse.ProtoReflect.Descriptor instead.
func (*EchoCountdownResponse) Descriptor() ([]byte, []int) {
	return file_proto_echo_proto_rawDescGZIP(), []int{6}
}

func (x *EchoCountdownResponse) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

var File_proto_echo_proto protoreflect.FileDescriptor

const file_proto_echo_proto_rawDesc = "" +
	"\n" +
	"\x10proto/echo.proto\x12\x04echo\"'\n" +
	"\vEchoRequest\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\"\xe5\x02\n" +
	"\fEchoResponse\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x129\n" +
	"\aheaders\x18\x02 \x03(\v2\x1f.echo.EchoResponse.HeadersEntryR\aheaders\x12\x1f\n" +
	"\vremote_addr\x18\x03 \x01(\tR\n" +
	"remoteAddr\x12(\n" +
	"\btls_info\x18\x04 \x01(\v2\r.echo.TLSInfoR\atlsInfo\x12-\n" +
	"\x03env\x18\x05 \x03(\v2\x1b.echo.EchoResponse.EnvEntryR\x03env\x1aN\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.echo.HeaderValuesR\x05value:\x028\x01\x1a6\n" +
	"\bEnvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"&\n" +
	"\fHeaderValues\x12\x16\n" +
	"\x06values\x18\x01 \x03(\tR\x06values\"\x8b\x02\n" +
	"\aTLSInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12!\n" +
	"\fcipher_suite\x18\x02 \x01(\tR\vcipherSuite\x128\n" +
	"\x18alpn_negotiated_protocol\x18\x03 \x01(\tR\x16alpnNegotiatedProtocol\x12E\n" +
	"\x11peer_certificates\x18\x04 \x03(\v2\x18.echo.TLSCertificateInfoR\x10peerCertificates\x12\x1f\n" +
	"\vserver_name\x18\x05 \x01(\tR\n" +
	"serverName\x12!\n" +
	"\fkey_exchange\x18\x06 \x01(\tR\vkeyExchange\"\xa7\x01\n" +
	"\x12TLSCertificateInfo\x12\x18\n" +
	"\asubject\x18\x01 \x01(\tR\asubject\x12\x16\n" +
	"\x06issuer\x18\x02 \x01(\tR\x06issuer\x12#\n" +
	"\rserial_number\x18\x03 \x01(\tR\fserialNumber\x12\x1d\n" +
	"\n" +
	"not_before\x18\x04 \x01(\tR\tnotBefore\x12\x1b\n" +
	"\tnot_after\x18\x05 \x01(\tR\bnotAfter\",\n" +
	"\x14EchoCountdownRequest\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x05R\x05start\"-\n" +
	"\x15EchoCountdownResponse\x12\x14\n" +
	"\x05count\x18\x01 \x01(\x05R\x05count2\x88\x01\n" +
	"\vEchoService\x12-\n" +
	"\x04Echo\x12\x11.echo.EchoRequest\x1a\x12.echo.EchoResponse\x12J\n" +
	"\rEchoCountdown\x12\x1a.echo.EchoCountdownRequest\x1a\x1b.echo.EchoCountdownResponse0\x01B%Z#github.com/tsaarni/echoserver/protob\x06proto3"

var (
	file_proto_echo_proto_rawDescOnce sync.Once
	file_proto_echo_proto_rawDescData []byte
)

func file_proto_echo_proto_rawDescGZIP() []byte {
	file_proto_echo_proto_rawDescOnce.Do(func() {
		file_proto_echo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_echo_proto_rawDesc), len(file_proto_echo_proto_rawDesc)))
	})
	return file_proto_echo_proto_rawDescData
}

var file_proto_echo_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_proto_echo_proto_goTypes = []any{
	(*EchoRequest)(nil),           // 0: echo.EchoRequest
	(*EchoResponse)(nil),          // 1: echo.EchoResponse
	(*HeaderValues)(nil),          // 2: echo.HeaderValues
	(*TLSInfo)(nil),               // 3: echo.TLSInfo
	(*TLSCertificateInfo)(nil),    // 4: echo.TLSCertificateInfo
	(*EchoCountdownRequest)(nil),  // 5: echo.EchoCountdownRequest
	(*EchoCountdownResponse)(nil), // 6: echo.EchoCountdownResponse
	nil,                           // 7: echo.EchoResponse.HeadersEntry
	nil,                           // 8: echo.EchoResponse.EnvEntry
}
var file_proto_echo_proto_depIdxs = []int32{
	7, // 0: echo.EchoResponse.headers:type_name -> echo.EchoResponse.HeadersEntry
	3, // 1: echo.EchoResponse.tls_info:type_name -> echo.TLSInfo
	8, // 2: echo.EchoResponse.env:type_name -> echo.EchoResponse.EnvEntry
	4, // 3: echo.TLSInfo.peer_certificates:type_name -> echo.TLSCertificateInfo
	2, // 4: echo.EchoResponse.HeadersEntry.value:type_name -> echo.HeaderValues
	0, // 5: echo.EchoService.Echo:input_type -> echo.EchoRequest
	5, // 6: echo.EchoService.EchoCountdown:input_type -> echo.EchoCountdownRequest
	1, // 7: echo.EchoService.Echo:output_type -> echo.EchoResponse
	6, // 8: echo.EchoService.EchoCountdown:output_type -> echo.EchoCountdownResponse
	7, // [7:9] is the sub-list for method output_type
	5, // [5:7] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_proto_echo_proto_init() }
func file_proto_echo_proto_init() {
	if File_proto_echo_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_echo_proto_rawDesc), len(file_proto_echo_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_echo_proto_goTypes,
		DependencyIndexes: file_proto_echo_proto_depIdxs,
		MessageInfos:      file_proto_echo_proto_msgTypes,
	}.Build()
	File_proto_echo_proto = out.File
	file_proto_echo_proto_goTypes = nil
	file_proto_echo_proto_depIdxs = nil
}
